"use strict";

var _util = require("./util");

var _screenForm = _interopRequireDefault(require("./screenForm"));

var _networkForm = _interopRequireDefault(require("./networkForm"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let b = document.body;
b.style.margin = 0;
b.style.padding = 0;
b.style.backgroundColor = 'lightgrey';
let globalBox = (0, _util.createElement)('div', {
  width: '100%',
  display: 'grid',
  gridTemplateColumns: '1fr 1fr',
  border: '5px solid pink'
}, b);
let netForm;
let scrnForm;

window.onload = function () {
  var networkCl = (0, _util.createColumn)(globalBox, 'Network Configuration');
  var get_data_device = fetch('http://localhost:80/info1');
  get_data_device.then(response => response.json()).then(dataDevice => {
    // networkForm.updateNetworkForm(Network.content,dataDevice);
    netForm = new _networkForm.default(dataDevice, networkCl.content); //console.log(netForm);
  });
  get_data_device.catch(e => {
    console.error(e);
  });
  const btnHideShowNet = new Button('Hide/Show', networkCl.column);
  btnHideShowNet.onClick(() => {
    networkCl.content.style.visibility = networkCl.content.style.visibility != 'visible' ? 'visible' : 'hidden';
  }); //const defaultValuesNet = networkCl.content;

  const btnResetNet = new Button('Reset', networkCl.column);
  btnResetNet.onClick(() => {
    window.location.reload(); //networkCl.content =defaultValuesNet;
  });
  const btnSubmitNet = new Button('Submit', networkCl.column);
  const resultNetform = new Result(networkCl.column);
  btnSubmitNet.onClick(() => {
    const data = netForm.getData();
    resultNetform.update(JSON.stringify(data));
  });
  var screenCl = (0, _util.createColumn)(globalBox, 'Screen Resolution Configuration');
  var get_data_screen = fetch('http://localhost:80/info2');
  get_data_screen.then(response => response.json()).then(dataScreen => {
    //screenForm.updateVideoForm(Screen.content, dataScreen);
    scrnForm = new ScreenTableForm(dataScreen, screenCl.content);
  });
  get_data_screen.catch(e => {
    console.error(e);
  });
  const btnHideShowScrn = new Button('Hide/Show', screenCl.column);
  btnHideShowScrn.onClick(() => {
    screenCl.content.style.visibility = screenCl.content.style.visibility != 'visible' ? 'visible' : 'hidden';
  }); //a tester 
  //	const defaultValuesScrn =screenCl.content;
  //console.log(screenCl.content)

  const btnResetScrn = new Button('Reset', screenCl.column);
  btnResetScrn.onClick(() => {
    window.location.reload(); //	screenCl.content=defaultValuesScrn;
  });
  const btnSubmitScrn = new Button('Submit', screenCl.column);
  const resultScrnForm = new Result(screenCl.column);
  btnSubmitScrn.onClick(() => {
    const data = scrnForm.getData();
    resultScrnForm.update(JSON.stringify(data));
  });
};

class Button {
  constructor(title, parentEl) {
    const button = (0, _util.createElement)('button', {
      margin: '10px'
    }, parentEl);
    button.innerText = title;
    button.addEventListener('click', () => {
      this.click();
    });
  }

  onClick(callback) {
    this.callback = callback;
  }

  click() {
    if (this.callback) this.callback;
  }

}

class Result {
  constructor(parentEl) {
    this.el = (0, _util.createElement)('div', {
      border: '1px solid gray',
      height: '10em'
    }, parentEl);
  }

  update(data) {
    this.el.innerHTML = data;
  }

}
/*
 PS: ne pas oublier la fct validSubmit qui verifie la saisie de chaque input:
  si chaque input et bien rempli niveau pattern longueur maximal 
 afin 
 d'alerte l'utilisateur de ce qu'il ne va pas et 
 de desactiver le btnSubmit lorsque les champs sont mal remplis.
 */


class ScreenTableForm {
  constructor(def, parentEl) {
    this.def = def;
    this.inputs = [];
    this.createTable(parentEl);
  }

  createTable(parentEl) {
    this.table = (0, _util.createElement)('table', {
      width: '100%'
    }, parentEl);
    Object.keys(this.def).forEach((obj, o) => {
      //console.log(this.def[obj]);
      var data = this.def[obj];
      const rowEl = (0, _util.createElement)('tr', {}, this.table);
      this.inputs.push([]);
      let connected = (0, _util.createElement)('td', {}, rowEl);
      connected.innerHTML = data.connected ? "&check;" : "&cross;";
      this.inputs[o].push(connected);
      let nameEl = (0, _util.createElement)('td', {}, rowEl);
      nameEl.innerHTML = obj;
      this.inputs[o].push(nameEl);
      let modes = (0, _util.createElement)('td', {}, rowEl);
      this.inputs[o].push(modes);
      let modesSelect = (0, _util.createElement)('select', {}, modes);

      if (data.modes.length == 0) {
        modesSelect.disabled = true;
      } else {
        data.modes.forEach(mode => {
          let opt = (0, _util.createElement)('option', {}, modesSelect);
          opt.text = `${mode.width}x${mode.height}@${mode.rate}`; //modesSelect.addEventListener('change',modesSelected);
        });
      }
    });
    console.log(this.inputs);
  }

  getData() {
    const data = []; //console.log(this.inputs)

    this.inputs.forEach(row => {
      let res = row.reduce((acc, el) => {
        acc[el.dataset.input] = el.value;
        return acc;
      }, {});
      data.push(res);
    }); //console.log(data);

    return data;
  }

}