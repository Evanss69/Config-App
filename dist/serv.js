/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./srcServ/ethernet_network.js":
/*!*************************************!*\
  !*** ./srcServ/ethernet_network.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Shell = __webpack_require__(/*! child_process */ \"child_process\");\n//const ShellNmcl = require('child_process');\n//const Network = require('./network');\n//const Util = require ('./util');\nconst EthernetNetwork = {\n    init() {\n\n    },\n    addConnection(){\n        return new Promise((resolve,reject)=>{\n            try{\n                Shell.execSync(`nmcli con add ifname \"*\" type ethernet con-name ethernet`)\n            }catch(e){\n                //console.error(e.message);\n                //reject(e);\n            }\n            var activRequest = `nmcli -p con up ethernet`;\n            Shell.exec(activRequest,(err,stdout,stderr)=>{\n                if (err){\n                    console.log('err:');\n                    console.log(err);\n                    console.log('==================================================\\n');\n                    reject(err);\n                }\n                if (stdout.match(/^Error:/)){\n                    console.log('stdout :')\n                   console.log(stdout);\n                    console.log('===============================================\\n');\n                    reject(stdout);\n                }else{\n                    resolve(JSON.stringify({Result : 'ok'}));\n                }     \n            });\n        })\n    },\n\n    activateConnection(dataConfigEthernet){\n        return new Promise((resolve,reject)=>{\n            if (dataConfigEthernet.activate == true) {\n                if(dataConfigEthernet.name=='undefined'){\n                const get_result=EthernetNetwork.addConnection();\n                   get_result.then((response)=>{\n                       resolve(response)\n                   });\n                    get_result.catch((err)=>{\n                        reject(err);\n                    });\n                }else{\n                    var activRequest = `nmcli -p con up ${dataConfigEthernet.name}`;\n                    Shell.exec(activRequest,(err,stdout,stderr)=>{\n                        if (err){\n                            console.log('err:');\n                            console.log(err);\n                            console.log('==================================================\\n');\n                            reject(err);\n                        }\n                        else {\n                            if (stdout.match(/^Error:/)){\n                                console.log('stdout :')\n                               console.log(stdout);\n                                console.log('===============================================\\n');\n                                reject(stdout);\n                            } else{\n                                resolve(JSON.stringify({Result : 'ok'}));\n                            }  \n                        }\n                        \n                           \n                    });\n                }\n            }\n        });\n    },\n\n    deactivateConnection(dataConfigEthernet){\n        return new Promise ((resolve,reject)=>{\n            var stopRequest = `nmcli -p con down ${dataConfigEthernet.name} `;\n            if (dataConfigEthernet.activate == true) {\n                Shell.exec(stopRequest,(err,stdout,stderr)=>{\n                    if (err) {\n                        console.log('err:');\n                        console.log(err);\n                        console.log('==================================================\\n');\n                        reject(err);\n                    }\n                    else {\n                        if (stdout.match(/^Error:/)) {\n                            console.log('stdout :')\n                            console.log(stdout)\n                            console.log('===============================================\\n');\n                            reject(stdout);\n\n                        } else {\n                            console.log({ Result: 'ok' });\n                            resolve(JSON.stringify({ Result: 'ok' }));\n                        }\n                    } \n                });\n            }\n        });\n    },\n\n    modifyConnection(dataConfigEthernet){\n        return new Promise((resolve,reject)=>{\n            console.log('dans le modify')\n            var modifyRequest = `nmcli con mod ${dataConfigEthernet.name} autoconnect on ipv6.method ignore `;\n            if (dataConfigEthernet.method == 'auto') {\n                modifyRequest +=` ipv4.method auto ipv4.addr \"\" ipv4.gateway \"\" ipv4.dns \"\"`;\n            } else {\n                modifyRequest += ` ipv4.method manual ipv4.addr ${dataConfigEthernet.ip}${dataConfigEthernet.mask}  `;\n                modifyRequest+= `ipv4.gateway ${dataConfigEthernet.gateway} ipv4.dns ${dataConfigEthernet.dns1}`;\n                if (dataConfigEthernet.dns2) {\n                    modifyRequest += ` +ipv4.dns ${dataConfigEthernet.dns2}`;\n                }    \n            }\n            try{\n                console.log({modifRequest: modifyRequest});\n                Shell.execSync(modifyRequest);\n            }catch(err){\n                console.log({erreur : err});\n                reject(err);\n            }\n            console.log('fin  de la premiere requete');\n            console.log('debut de la deactivation ')\n           const get_response= EthernetNetwork.deactivateConnection(dataConfigEthernet);\n            get_response.then((response_deactivate)=>{\n                console.log('fin de la deativation');\n                console.log('debut de l activation');\n               const get_result= EthernetNetwork.activateConnection(dataConfigEthernet);\n               get_result .then((response)=>{\n                console.log('fin de l activation')\n                    console.log({reponse:response});\n                    resolve(response);\n                })\n                get_result.catch((err)=>{\n                    console.log({erreur:err});\n                    reject(err);\n                });\n            })\n            get_response.catch((err)=>{\n                console.log({erreur:err});\n                reject(err);\n            });\n        });\n      \n    },\n\n    updateConfig(dataConfigEthernet) {\n     return new Promise((resolve,reject)=>{\n        console.log({fichier:'EthernetNetwork'+'updateConfig'})\n        if(dataConfigEthernet && dataConfigEthernet.activate==true){\n            console.log('apres le if')\n           const get_result= EthernetNetwork.modifyConnection(dataConfigEthernet);\n            get_result.then((response)=>{\n                console.log({reponse_de_la_methode_modify: response})\n                resolve(response);\n            });\n            get_result.catch((err)=>{\n                console.log({errModify:err});\n                reject(err);\n            });\n        }\n     });\n    },\n\n\n}\nmodule.exports =EthernetNetwork;\n /*  var modifyRequest = `nmcli con mod ${dataConfigEthernet.name} ipv4.gateway ${dataConfigEthernet.gateway} ipv4.dns ${dataConfigEthernet.dns1}`;\n        var activRequest = `nmcli con mod ${dataConfigEthernet.name} ipv6.method ignore; nmcli -p con up ${dataConfigEthernet.name} `;\n        var stopRequest = `nmcli -p con down ${dataConfigEthernet.name} `;\n        if (dataConfigEthernet.dns2) {\n            modifyRequest = `${modifyRequest} +ipv4.dns ${dataConfigEthernet.dns2}`;\n        }\n        if (dataConfigEthernet.activate == true) {\n            Shell.execSync(activRequest);\n        } else if (dataConfigEthernet.activate == false) {\n            Shell.execSync(stopRequest);\n        }\n        if (dataConfigEthernet && dataConfigEthernet.activate == undefined) {\n            //\n            //console.log(connectionList);\n            //console.log(dataConfigEthernet.type);\n            //if (Util.checkExistingConnection(connectionList,dataConfigEthernet.name) == true) {\n\n                if (dataConfigEthernet.method == 'auto') {\n                    var req = `nmcli con mod ${dataConfigEthernet.name} autoconnect on ipv6.method ignore ipv4.method auto ipv4.addr \"\" ipv4.gateway \"\" ipv4.dns \"\"`;\n                    Shell.execSync(req);\n                } else {\n                    var req = `nmcli con mod ${dataConfigEthernet.name} autoconnect on ipv6.method ignore ipv4.method manual ipv4.addr ${dataConfigEthernet.ip}${dataConfigEthernet.mask} `;\n                    Shell.execSync(req);\n                    Shell.execSync(modifyRequest);\n                }   \n               // }\n          //  }\n            // Shell.execSync(stopRequest);\n            // Shell.execSync(activRequest);\n        }*/\n\n//# sourceURL=webpack://my-webpack-project/./srcServ/ethernet_network.js?");

/***/ }),

/***/ "./srcServ/network.js":
/*!****************************!*\
  !*** ./srcServ/network.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Shell = __webpack_require__(/*! child_process */ \"child_process\");\nconst ShellNmcl = __webpack_require__(/*! child_process */ \"child_process\");\nconst EthernetNetwork = __webpack_require__(/*! ./ethernet_network */ \"./srcServ/ethernet_network.js\");\n//const { getWifiList } = require('./wifi_network');\nconst WifiNetwork = __webpack_require__(/*! ./wifi_network */ \"./srcServ/wifi_network.js\");\n\nconst Network = {\n\n    init() {\n\n    },\n    mapp:\n    {\n        \"GENERAL.CONNECTION\": \"name\",\n        \"GENERAL.TYPE\": \"type\",\n        \"GENERAL.DEVICE\": \"device\",\n        \"GENERAL.STATE\": \"state\",\n        //\"GENERAL.HWADDR\": \"mac\",\n        \"IP4.ADDRESS[1]\": \"ip\",\n        \"IP4.GATEWAY\": \"gateway\",\n        \"IP4.DNS[1]\": \"dns1\",\n        \"IP4.DNS[2]\": \"dns2\",\n        \"IP4.DOMAIN[1]\": \"area\",\n        \"IP4.ROUTE[1]\": \"road1\",\n        \"IP4.ROUTE[2]\": \"road2\",\n        \"IP4.ROUTE[3]\": \"road3\"\n    },\n    con_mapping: {\n        \"GENERAL.NAME\": \"name\",\n        // \"GENERAL.TYPE\": \"type\",\n        \"802-11-wireless.ssid\": \"ssid\",\n        \"GENERAL.DEVICES\": \"device\",\n        \"GENERAL.STATE\": \"state\",\n        //\"GENERAL.HWADDR\": \"mac\",\n        \"ipv4.method\": \"method\",\n        \"IP4.ADDRESS[1]\": \"ip\",\n        \"IP4.GATEWAY\": \"gateway\",\n        \"IP4.DNS[1]\": \"dns1\",\n        \"IP4.DNS[2]\": \"dns2\",\n    },\n\n    getNetworkConfig() {\n        return new Promise((resolve, reject) => {\n\n            const get_networks = Network.getNetworks();\n            get_networks.then((networks) => {\n                //console.log(networks);\n                const res = {\n                    \"ethernet\": { device_state: networks['ethernet'].state },\n                    \"wifi\": { device_state: networks['wifi'].state }\n                };\n                const connection = networks['ethernet'].connection;\n                if (connection) {\n                    Object.assign(res[\"ethernet\"], Network.getConfig(connection));\n                }\n                const wifi = networks['wifi'].connection;\n                if (wifi) {\n                    Object.assign(res['wifi'], Network.getConfig(wifi));\n                }\n                resolve(res);\n            });\n            get_networks.catch((e) => {\n                reject(e.message);\n            });\n        })\n    },\n\n\n    getNetworks() {\n        return new Promise((resolve, reject) => {\n            try {\n                const networks = {};\n                const devList = ShellNmcl.execSync('nmcli -t dev');\n\n                devList.toString().split('\\n').forEach((l) => {\n                    const [device, type, state, connection] = l.split(':');\n                    if (type == \"ethernet\" || type == \"wifi\") {\n                        if (!networks[type]) {\n                            networks[type] = { device: device, state: state, connection: connection };\n                        }\n                    }\n                });\n                resolve(networks);\n            }\n            catch (e) {\n                reject(e.message);\n            }\n        })\n    },\n\n    getConfig(connection) {\n\n        try {\n            const config = {};\n            const raw_config = ShellNmcl.execSync(`nmcli -t -f GENERAL.NAME,GENERAL.DEVICES,GENERAL.STATE,IP4.ADDRESS,IP4.GATEWAY,IP4.DNS,ipv4.method,802-11-wireless.ssid con show  ${connection}`);\n            raw_config.toString().split('\\n').forEach((l) => {\n                const [k, v] = l.split(':');\n                //console.log(k + \" => \" + v);\n                if (this.con_mapping[k]) {\n                    config[this.con_mapping[k]] = v;\n                }\n            });\n           // console.log(config)\n            return config;\n        }\n        catch (e) {\n            return { state: 'error: ' + e.message };\n        }\n\n    },\n\n    //for update\n    getConnectionList() {\n        return new Promise((resolve, reject) => {\n            let connectionList = [];\n            const searchReq = \"nmcli -mode tabular -g name con show\";\n            Shell.exec(searchReq, (err, stdout, stderr) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    connectionList = stdout.split('\\n').filter(l => !!l);\n                    resolve(connectionList);\n                }\n            })\n        })\n    },\n    getWifiList(){\n            \n        return new Promise((resolve, reject) => {\n\n            const get_wifi_list = WifiNetwork.getWifiList();\n            get_wifi_list.then((wifiList) => {\n                resolve(wifiList);\n            });\n            get_wifi_list.catch((e) => {\n                reject(e);\n            });\n        })\n    },\n\n    updateConfig(dataConfig, connectionList) {\n        return new Promise((resolve,reject)=>{\n            if (dataConfig.type == 'ethernet') {\n                var dataConfigEthernet = dataConfig;\n                console.log({config: 'ethernet'});\n                 const get_result= EthernetNetwork.updateConfig(dataConfigEthernet)\n                 get_result.then((response)=>{\n                     resolve(response);\n                 });\n                 get_result.catch((e)=>{\n                    reject(e);\n\n                 });\n\n            }else {\n                var dataConfigWifi = dataConfig;\n                 console.log({config: 'wifi'});\n                const get_result= WifiNetwork.updateConfig(dataConfigWifi,connectionList)\n                get_result.then((response)=>{\n                    console.log(response);\n                    resolve(response);\n                });\n                get_result.catch((e)=>{\n                    console.log(e.message);\n                    reject(e);\n                });\n\n            }\n        });\n        /*console.log(dataConfig[0].type);\n        var dataConfigEthernet = dataConfig[0];\n        if (dataConfig[1]) {\n            var dataConfigWifi = dataConfig[1];      \n            WifiNetwork.wifiConfig(dataConfigWifi, connectionList);  \n        }else if(dataConfig !=null){\n            EthernetNetwork.updateConfig(dataConfigEthernet, connectionList);\n        }        */\n    },\n    activateConnection(dataConfig){\n        return new Promise((resolve,reject)=>{\n            if (dataConfig.type == 'ethernet') {\n                var dataConfigEthernet = dataConfig;\n                 const get_result= EthernetNetwork.activateConnection(dataConfigEthernet)\n                 get_result.then((response)=>{\n                     resolve(response);\n                 });\n                 get_result.catch((e)=>{\n                    reject(e);\n\n                 });\n\n            }else {\n                var dataConfigWifi = dataConfig;\n                   // console.log(WifiNetwork.updateConfig(dataConfigWifi, connectionList));\n                const get_result= WifiNetwork.activateConnection(dataConfigWifi)\n                get_result.then((response)=>{\n                    resolve(response);\n                });\n                get_result.catch((e)=>{\n                    reject(e);\n                });\n\n            }\n        });\n    },\n    deactivateConnection(dataConfig){\n        return new Promise((resolve,reject)=>{\n            if (dataConfig.type == 'ethernet') {\n                var dataConfigEthernet = dataConfig;\n                 const get_result= EthernetNetwork.deactivateConnection(dataConfigEthernet)\n                 get_result.then((response)=>{\n                     resolve(response);\n                 });\n                 get_result.catch((e)=>{\n                    reject(e);\n\n                 });\n\n            }else {\n                var dataConfigWifi = dataConfig;\n                   // console.log(WifiNetwork.updateConfig(dataConfigWifi, connectionList));\n                const get_result= WifiNetwork.deactivateConnection(dataConfigWifi)\n                get_result.then((response)=>{\n                    resolve(response);\n                });\n                get_result.catch((e)=>{\n                    reject(e);\n                });\n\n            }\n        });\n    },\n\n\n\n}\nmodule.exports = Network;\n\n    /*\ngetConfigNetwork() {\n    // nmcli -t -f GENERAL.CONNECTION,GENERAL.TYPE,GENERAL.DEVICE,GENERAL.STATE,GENERAL.HWADDR,IP4 device show\n\n    return new Promise((resolve, reject) => {\n        ShellNmcl.exec('nmcli -t -f GENERAL.CONNECTION,GENERAL.TYPE,GENERAL.DEVICE,GENERAL.STATE,GENERAL.HWADDR,IP4 device show ', (err, stdout, stderr) => {\n            if (err) {\n                reject(err);\n            }\n            else { //parsage\n                var infosConfigNetwork = [];\n                var idx = 0;\n\n                stdout.split('\\n').forEach((l) => {\n                    if (l == \"\") { idx++; }\n                    else {\n                        //console.log(l);\n                        const [k, v] = l.split(':');\n                        if (!infosConfigNetwork[idx]) infosConfigNetwork[idx] = {};\n                        //if(typeof v == 'array') v = v.join(':');\n                        let field = Infosconfig.mapp[k];\n                        if (field) { infosConfigNetwork[idx][field] = v; }\n                    }\n\n                });\n\n                const filteredList = infosConfigNetwork.filter(it => it.type == 'wifi' || it.type == \"ethernet\");\n\n                resolve(filteredList);\n            }\n        });\n    });\n},\n*/\n   /* deleteRequest(device, connectionList, oldConName, conName) {\n        // console.log(device);\n\n        for (var i = 0; i < connectionList.length; i++) {\n           // console.log(connectionList[i]);\n            if (connectionList[i] == /[A-Z][A-Za-z\\é\\è\\ê\\-]+$/ + `${device}`) {\n               // console.log('trouver');\n                deleteDefaultConRequest = `nmcli connection delete ${connectionList[i]}`;\n                Shell.execSync(deleteDefaultConName);\n            }\n        }\n        if (oldConName && conName) {\n            if (oldConName != conName) {\n                var deleteRequest = `nmcli connection delete ${oldConName}`;\n                Shell.execFileSync(deleteRequest);\n            }\n        }\n\n    },*/\n\n//# sourceURL=webpack://my-webpack-project/./srcServ/network.js?");

/***/ }),

/***/ "./srcServ/parserXrandr.js":
/*!*********************************!*\
  !*** ./srcServ/parserXrandr.js ***!
  \*********************************/
/***/ ((module) => {

eval("\n/*var fs = require('fs');\n\nvar output = fs.readFileSync('./xrandr_output.txt');\nconsole.log(output);\n\nconsole.log(parseXrandr(output.toString()));\n*/\nconst xrandrParser={\n     parseXrandr(src) {\n        var lines = src.split('\\n');\n        var query = {};\n        var last = null;\n        var index = 0;\n        \n        var re = {\n            connected: /^(\\S+) connected (?:(\\d+)x(\\d+))?/,\n            disconnected: /^(\\S+) disconnected/,\n            mode: /^\\s+(\\d+)x([0-9i]+)\\s+((?:\\d+\\.)?\\d+)([* ]?)([+ ]?)/\n        };\n    \n        lines.forEach(function (line) {\n            var m;\n            if (m = re.connected.exec(line)) {\n                query[m[1]] = {\n                    connected: true,\n                    modes: [],\n                    index: index++\n                };\n                if (m[2] && m[3]) {\n                    query[m[1]].width = parseInt(m[2]);\n                    query[m[1]].height = parseInt(m[3]);\n                }\n                last = m[1];\n            }\n            else if (m = re.disconnected.exec(line)) {\n                query[m[1]] = {\n                    connected: false,\n                    modes: [],\n                    index: index++\n                };\n                last = m[1];\n            }\n            else if (last && (m = re.mode.exec(line))) {\n                var r = {\n                    width: m[1],\n                    height: m[2],\n                    rate: parseFloat(m[3])\n                };\n                query[last].modes.push(r);\n                \n                if (m[4] === '+' || m[5] === '+') query[last]['native'] = r;\n                if (m[4] === '*' || m[5] === '*') query[last].current = r;\n            }\n            else {\n                last = null;\n            }\n        });\n        return query;\n    }\n}\nmodule.exports = xrandrParser;\n\n\n\n//# sourceURL=webpack://my-webpack-project/./srcServ/parserXrandr.js?");

/***/ }),

/***/ "./srcServ/screen.js":
/*!***************************!*\
  !*** ./srcServ/screen.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Shell = __webpack_require__(/*! child_process */ \"child_process\");\nconst ShellXrndr = __webpack_require__(/*! child_process */ \"child_process\");\nconst { stderr } = __webpack_require__(/*! process */ \"process\");\nconst xrandrParser = __webpack_require__(/*! ./parserXrandr */ \"./srcServ/parserXrandr.js\");\nconst Screen = {\n\n    init() {\n\n    },\n\n    getResolutionList() {\n\n        return new Promise\n            (\n                (resolve, reject) => {\n\n                    ShellXrndr.exec('xrandr', function (err, stdout, stderr) {\n                        if (err) {\n                            reject(err);\n                        }\n                        else {\n                            //parsage\n                            var resolutionList = xrandrParser.parseXrandr(stdout);\n                            //console.log(xrandrParser.parseXrandr(stdout));\n                            resolve(resolutionList);\n                        }\n                    });\n                });\n    },\n\n    updateConfig(dataConfig) {\n        //console.log(dataConfig);\n        return new Promise((resolve,reject)=>{\n            var config = dataConfig;\n            const modeChoice = config.mode.replace('@', ' --rate ');\n            const screenInterface = config.name;\n            req = 'xrandr --output ' + screenInterface + ' --mode ' + modeChoice;\n            Shell.exec(req,(err,stdout,stderr)=>{\n                if(err){\n                    reject(err);\n                }if (stdout.match(/^Error:/)){\n                    reject(stdout);\n                }else{\n                    resolve(JSON.stringify({Result: 'ok'}))\n                }\n            });\n        })\n       \n    },\n}\nmodule.exports = Screen;\n\n//# sourceURL=webpack://my-webpack-project/./srcServ/screen.js?");

/***/ }),

/***/ "./srcServ/util.js":
/*!*************************!*\
  !*** ./srcServ/util.js ***!
  \*************************/
/***/ ((module) => {

eval("const Util = {\n    checkExistingConnection(connectionList, name) {\n        var result = false;\n        for (i = 0; i < connectionList.length; i++) {\n            if (connectionList[i] == name) {\n                result = true;\n                //console.log(result);\n                return result;\n            }\n        }\n        //console.log(result);\n        return result;\n    }\n\n}\n\nmodule.exports = Util;\n\n//# sourceURL=webpack://my-webpack-project/./srcServ/util.js?");

/***/ }),

/***/ "./srcServ/wifi_network.js":
/*!*********************************!*\
  !*** ./srcServ/wifi_network.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Shell = __webpack_require__(/*! child_process */ \"child_process\");\n//const ShellNmcl = require('child_process');\n//const Network = require('./network');\nconst Util = __webpack_require__(/*! ./util */ \"./srcServ/util.js\");\nconst WifiNetwork = {\n\n    init() {\n\n    },\n\n    getWifiList() {\n        return new Promise((resolve, reject) => {\n            Shell.exec('nmcli -f SSID device wifi list ', (err, stdout, stderr) => {\n                if (err) {\n                    reject(err);\n                } else { //parsage\n                    var tab = [];\n                    tab = stdout.split('\\n');\n                    var wifiList = [];\n                    for (i = 1; i < tab.length - 1; i++) {\n                        wifiList[i - 1] = tab[i].trim();\n                    }\n                    resolve(wifiList);\n                }\n            });\n        });\n    },\n\n    activateConnection(dataConfigWifi) {\n        return new Promise((resolve, reject) => {\n            var connectRequest = `nmcli -ask device wifi connect ${dataConfigWifi.SSID} password ${dataConfigWifi.password}`;\n            if (dataConfigWifi.activate == true) {\n                Shell.exec(connectRequest, (err, stdout, stderr) => {\n                    console.log('stdout:  ');\n                    if (err) {\n                        console.log('il y a eu erreur');\n                        reject(err);\n                    }\n                    else {\n                        console.log(stdout);\n                        if (stdout.match(/^Error:/)) {\n                            console.log('match trouver');\n                            reject(stdout);\n                        } else {\n                            resolve(JSON.stringify({ Result: 'ok' }));\n                        }\n                    }\n                   \n                    \n                });\n            }\n        });\n\n    },\n\n\n    deactivateConnection(dataConfigWifi) {\n        return new Promise((resolve, reject) => {\n            var disconnectRequest = `nmcli con down ${dataConfigWifi.SSID}`;\n            if (dataConfigWifi.activate == false) {\n                Shell.exec(disconnectRequest, (err, stdout, stderr) => {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        if (stdout.match(/^Error:/)) {\n                            reject(stdout);\n                        } else {\n                            resolve(JSON.stringify({ Result: 'ok' }));\n                        }\n                    }\n\n                });\n            }\n        });\n\n    },\n\n    modifyConnection(dataConfigWifi) {\n        return new Promise((resolve,reject)=>{\n            var modifyRequest = `nmcli con mod ${dataConfigWifi.SSID} ipv6.method ignore autoconnect on`;\n            var connectRequest = `nmcli con up ${dataConfigWifi.SSID} `;\n    \n            if (dataConfigWifi.method == 'auto') {\n                modifyRequest = `${modifyRequest} ipv4.method auto ipv4.addr \"\" ipv4.gateway \"\" ipv4.dns \"\"`;\n            } else {\n                modifyRequest = `${modifyRequest} ipv4.method manual ipv4.addr ${dataConfigWifi.ip}${dataConfigWifi.mask}`;\n                modifyRequest = `${modifyRequest} ipv4.gateway ${dataConfigWifi.gateway} ipv4.dns ${dataConfigWifi.dns1}`;\n                if (dataConfigWifi.dns2) {\n                    modifyRequest = `${modifyRequest} +ipv4.dns ${dataConfigWifi.dns2}`;\n                }\n            }\n            try{\n                Shell.execSync(modifyRequest);\n            }catch(err){\n                reject(err);\n            }\n            this.deactivateConnection(dataConfigWifi).then(() => {\n                _tryConnect(connectRequest).then(resolve).catch(reject);\n            }).catch(reject);\n        });\n    },\n\n    _tryConnect(connectRequest) {\n        Shell.exec(connectRequest, (err, stdout, stderr) => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                if (stdout.match(/^Error:/)) {\n                    reject(stdout);\n                } else {\n                    resolve(JSON.stringify({ Result: 'ok' }));\n                }\n            }\n        });\n    },\n\n    addConnection(dataConfigWifi) {\n        return new Promise((resolve,reject)=>{\n            var addRequest = `nmcli con add type wifi con-name ${dataConfigWifi.SSID}  ssid ${dataConfigWifi.SSID}`;\n            var modifyRequest = `nmcli con mod ${dataConfigWifi.SSID} ipv6.method ignore autoconnect on`;\n\n            if (dataConfigWifi.method == 'auto') {\n                modifyRequest = `${modifyRequest} ipv4.method auto ipv4.addr \"\" ipv4.gateway \"\" ipv4.dns \"\" `;\n            } else {\n                modifyRequest = `${modifyRequest} ipv4.method manual ipv4.addr ${dataConfigWifi.ip}${dataConfigWifi.mask}`;\n                modifyRequest = `${modifyRequest} ipv4.gateway ${dataConfigWifi.gateway} ipv4.dns ${dataConfigWifi.dns1}`;\n                if (dataConfigWifi.dns2) {\n                    modifyRequest = `${modifyRequest} +ipv4.dns ${dataConfigWifi.dns2}`;\n                }\n            }\n            try{\n                Shell.execSync(addRequest);\n                Shell.execSync(modifyRequest);\n            }catch(err){\n                reject(err);\n            }\n            this.activateConnection(dataConfigWifi)\n            .then((response)=>{\n             resolve(response);\n            })\n            .catch((err)=>{\n             reject(err);\n            });\n        });\n    },\n\n    updateConfig(dataConfigWifi, connectionList) {\n        return new Promise((resolve, reject) => {\n            var get_result;\n            if (dataConfigWifi && dataConfigWifi.activate == true) {\n                if (Util.checkExistingConnection(connectionList, dataConfigWifi.SSID) == true) {\n                    get_result = this.modifyConnection(dataConfigWifi);\n                    get_result.then((response) => {\n                        resolve(response);\n                    });\n                    get_result.catch((err) => {\n                        reject(err);\n                    });\n                } else {\n                    get_result = this.addConnection(dataConfigWifi);\n                    get_result.then((response) => {\n                        resolve(response);\n                    });\n                    get_result.catch((err) => {\n                        reject(err);\n                    });\n                }\n            }\n        });\n    },\n}\nmodule.exports = WifiNetwork;\n\n//# sourceURL=webpack://my-webpack-project/./srcServ/wifi_network.js?");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");;

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");;

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");;

/***/ }),

/***/ "process":
/*!**************************!*\
  !*** external "process" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("process");;

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
(() => {
/*!*************************!*\
  !*** ./srcServ/serv.js ***!
  \*************************/
eval("var http = __webpack_require__(/*! http */ \"http\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar URL = __webpack_require__(/*! url */ \"url\");\n//const Infosconfig = require('./infosconfig');\nconst Network = __webpack_require__(/*! ./network */ \"./srcServ/network.js\");\n//const WifiNetwork = require ('./wifi_network');\n//const EthernetNetwork = require ('./ethernet_network'); \nconst Screen = __webpack_require__(/*! ./screen */ \"./srcServ/screen.js\");\n/*\nconst routes = [\n\t{ path: '/get_network_config', method: 'GET', fn: Network.getConfigNetwork },\n\t{ path: '/get_screen_config', method: 'GET', fn: Screen.getResolution },\n];\n\nObject.keys(routes).forEach((route) => {\n\tif(route.path == parsed.pathname && route.method == req.method ) {\n\t\tif(route.method == 'POST') {\n\t\t\tlet body = \"\";\n\t\t\treq.on('data', (chunk) => { body += chunk.toString(); });\n\t\t\treq.on('end', () => {\n\t\t\t\tconst data = JSON.parse(body);\n\t\t\t\troute.fn(data);\n\t\t\t});\n\t\t}\n\t\telse {\t\n\t\t\troute.fn();\n\t\t}\n\t}\n});*/\n\nfunction handle_request(req, res) {\n\tvar parsed = URL.parse(req.url);\n\t//console.log(parsed.pathname);\n\n\tvar appmatch = parsed.pathname.match(/app\\..*\\.js/);\n\tvar appname = appmatch && appmatch.input;\n\n\tswitch (parsed.pathname) {\n\t\tcase '/get_network_config':\n\t\t\t//=== test\n\t\t\tconst get_network_config = Network.getNetworkConfig();\n\t\t\tget_network_config.then((config) => {\n\t\t\t\tres.writeHead(200, { 'Content-Type': 'application/json' });\n\t\t\t\tres.end(JSON.stringify(config));\n\t\t\t\t//console.log(config); \n\t\t\t});\n\t\t\tget_network_config.catch((err) => {\n\t\t\t\tres.writeHead(500, { 'Content-Type': 'application/json' });\n\t\t\t\tres.end(JSON.stringify(err));\n\t\t\t\t//console.log(err); \n\t\t\t});\n\t\t\t//=== test\n\n\t\t\t/*\n\t\t\tvar get_info_configNet = Network.getConfigNetwork();\n\t\t\tget_info_configNet.then((info) => {\n\t\t\t\tres.writeHead(200, { 'Content-Type': 'application/json' });\n\t\t\t\tres.end(JSON.stringify(info));\n\t\t\t});\n\t\t\tget_info_configNet.catch((err) => {\n\t\t\t\tres.writeHead(500, { 'Content-Type': 'application/json' });\n\t\t\t\tres.end(JSON.stringify(err));\n\t\t\t});\n\t\t\t*/\n\t\t\tbreak;\n\n\t\tcase '/get_screen_config':\n\t\t\tvar get_ResolutionList = Screen.getResolutionList();\n\t\t\tget_ResolutionList.then((resolutionList) => {\n\t\t\t\tres.writeHead(200, { 'Content-Type': 'application/json' });\n\t\t\t\tres.end(JSON.stringify(resolutionList));\n\t\t\t});\n\t\t\tget_ResolutionList.catch((err) => {\n\t\t\t\tres.writeHead(500, { 'Content-Type': 'application/json' });\n\t\t\t\tres.end(JSON.stringify(err));\n\t\t\t});\n\t\t\tbreak;\n\n\t\tcase '/get_wifiList_ssids':\n\t\t\tvar get_wifiList = Network.getWifiList();\n\t\t\tget_wifiList.then((wifiList) => {\n\t\t\t\tres.writeHead(200, { 'Content-Type': 'application/json' });\n\t\t\t\tres.end(JSON.stringify(wifiList));\n\t\t\t});\n\t\t\tget_wifiList.catch((err) => {\n\t\t\t\tres.writeHead(500, { 'Content-Type': 'application/json' });\n\t\t\t\tres.end(JSON.stringify(err));\n\t\t\t});\n\t\t\tbreak;\n\n\t\tcase '/activate_network':\n\t\t\tif (req.method == 'POST') {\n\t\t\t\t//console.log(req);\n\t\t\t\tvar body = \"\";\n\t\t\t\treq.on('data', (chunk) => { body += chunk.toString(); });\n\t\t\t\treq.on('end', () => {\n\t\t\t\t\t//console.log(JSON.parse(body));\n\t\t\t\t\tconst network_config_params = JSON.parse(body);\n\t\t\t\t\tconst get_result = Network.activateConnection(network_config_params);\n\t\t\t\t\tget_result.then((response) => {\n\t\t\t\t\t\tres.writeHead(200, { 'Content-Type': 'application/json' });\n\t\t\t\t\t\tres.end(response);\n\t\t\t\t\t})\n\t\t\t\t\tget_result.catch((err) => {\n\t\t\t\t\t\tres.writeHead(500, { 'Content-Type': 'application/json' });\n\t\t\t\t\t\tres.end(JSON.stringify(err.message));\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tres.end();\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '/deactivate_network':\n\t\t\tif (req.method == 'POST') {\n\t\t\t\t//console.log(req);\n\t\t\t\tvar body = \"\";\n\t\t\t\treq.on('data', (chunk) => { body += chunk.toString(); });\n\t\t\t\treq.on('end', () => {\n\t\t\t\t\t//console.log(JSON.parse(body));\n\t\t\t\t\tconst network_config_params = JSON.parse(body);\n\t\t\t\t\tconst get_result = Network.deactivateConnection(network_config_params);\n\t\t\t\t\tget_result.then((response) => {\n\t\t\t\t\t\tres.writeHead(200, { 'Content-Type': 'application/json' });\n\t\t\t\t\t\tres.end(response);\n\t\t\t\t\t})\n\t\t\t\t\tget_result.catch((err) => {\n\t\t\t\t\t\tres.writeHead(500, { 'Content-Type': 'application/json' });\n\t\t\t\t\t\tres.end(JSON.stringify(err.message));\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tres.end();\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '/update_network_config':\n\t\t\tif (req.method == 'POST') {\n\t\t\t\t//console.log(req);\n\t\t\t\tvar body = \"\";\n\t\t\t\treq.on('data', (chunk) => { body += chunk.toString(); });\n\t\t\t\treq.on('end', () => {\n\t\t\t\t\t//console.log(JSON.parse(body));\n\t\t\t\t\tconst network_config_params = JSON.parse(body);\n\t\t\t\t\tvar get_connectionList = Network.getConnectionList();\n\t\t\t\t\tget_connectionList.then((connectionList) => {\n\t\t\t\t\t\tconst get_result = Network.updateConfig(network_config_params, connectionList);\n\t\t\t\t\t\tget_result.then((response) => {\n\t\t\t\t\t\t\tres.writeHead(200, { 'Content-Type': 'application/json' });\n\t\t\t\t\t\t\tres.end(response);\n\t\t\t\t\t\t})\n\t\t\t\t\t\tget_result.catch((err) => {\n\t\t\t\t\t\t\tres.writeHead(500, { 'Content-Type': 'application/json' });\n\t\t\t\t\t\t\tres.end(JSON.stringify(err.message));\n\t\t\t\t\t\t});\n\t\t\t\t\t})\n\t\t\t\t\tget_connectionList.catch((err) => {\n\t\t\t\t\t\tres.writeHead(500, { 'Content-Type': 'application/json' });\n\t\t\t\t\t\tres.end(JSON.stringify(err));\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tres.end();\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '/update_screen_config':\n\t\t\tif (req.method == 'POST') {\n\t\t\t\tvar body = \"\";\n\t\t\t\treq.on('data', (chunk) => { body += chunk.toString(); });\n\t\t\t\treq.on('end', () => {\n\t\t\t\t\tconst screen_config_params = JSON.parse(body);\n\t\t\t\t\t//console.log(screen_config_params);\n\t\t\t\t\tconst get_result = Screen.updateConfig(screen_config_params);\n\t\t\t\t\tget_result.then((response) => {\n\t\t\t\t\t\tres.writeHead(200, { 'Content-Type': 'application/json' });\n\t\t\t\t\t\tres.end(response);\n\t\t\t\t\t})\n\t\t\t\t\tget_result.catch((e) => {\n\t\t\t\t\t\terr = e.message;\n\t\t\t\t\t\t//console.log(e.message);\n\t\t\t\t\t\tres.writeHead(500, { 'Content-Type': 'application/json' });\n\t\t\t\t\t\tres.end(JSON.stringify(err));\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tres.end();\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\n\t\tcase '/index.html':\n\t\tcase '/':\n\t\t\tres.writeHead(200, { 'Content-Type': 'text/html' });\n\t\t\tres.end(fs.readFileSync('./dist/index.html'));\n\t\t\tbreak;\n\n\t\t// serve assets\n\t\tcase String(parsed.pathname.match(/^\\/dist\\/.*/)):\n\t\t\tconsole.log(parsed.pathname);\n\t\t\tfs.readFile('./' + parsed.pathname, function (err, data) {\n\t\t\t\tif (err) {\n\t\t\t\t\tres.writeHead(404, { 'ContentType': 'text/plain;charset=UTF-8' });\n\t\t\t\t\tres.end(JSON.stringify(':('));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres.writeHead(200, { 'ContentType': 'text/plain;charset=UTF-8' });\n\t\t\t\t\tres.end(data);\n\t\t\t\t}\n\t\t\t});\n\t\t\tbreak;\n\n\t\t// serve app.js\n/* \t\tcase '/app.js':\n\t\tcase appname:\n\t\t\t// case String(parsed.pathname.match(/app\\..*\\.js/)):\n\t\t\t// \tvar appmatch = parsed.pathname.match(/app\\..*\\.js/);\n\t\t\t// \tvar appname = appmatch && appmatch.input;\n\t\t\t// \tconsole.log(appname);\n\t\t\tres.writeHead(200, { 'Content-Type': 'application/javascript' });\n\t\t\tres.end(fs.readFileSync('./' + appname));\n\t\t\tbreak; */\n\n\t\tdefault:\n\t\t\tres.writeHead(404, { 'Content-Type': 'text/plain' });\n\t\t\tres.end(JSON.stringify(':('));\n\t\t\tbreak;\n\t}\n\n}\n\n\nvar server = http.createServer(handle_request);\n\nconsole.log(\"Running\");\nconsole.log(\"Listening on 127.0.0.1:8080\");\nserver.listen(8080, '127.0.0.1');\n\n\n\n\n\n//# sourceURL=webpack://my-webpack-project/./srcServ/serv.js?");
})();

/******/ })()
;